<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Timeline 2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->

    <link href="/-assets/css/bootstrap.css" rel="stylesheet">
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }

      #nowbtn {
        position: fixed; 
        top: 200px; 
        left: 20px
      }


    </style>
    <link href="/-assets/css/bootstrap-responsive.css" rel="stylesheet">
    <link rel="stylesheet" href="http://f.fontdeck.com/s/css/DtjAfB+w7lb2Z6E8TZsiEMmPsFk/scratch.iandavis.com/23972.css" type="text/css" />
    <link href="/-assets/css/app.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/-assets/ico/favicon.ico">

    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/-assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/-assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/-assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="/-assets/ico/apple-touch-icon-57-precomposed.png">




  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">

        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/">Project name</a>
          <div class="nav-collapse">

            <ul class="nav">
              <li class="active"><a href="/">Home</a></li>
              <li><a href="#about">About</a></li>
              <li><a href="#contact">Contact</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>

      </div>
    </div>

    <div class="container">


      <!-- Example row of columns -->
      <div class="row">
        <div class="span2">

        </div>
        <div class="span8">
          <div id="container">
            <!-- Content will be loaded here dynamically. -->
          </div>        
          <div id="nowbtn"><a class="btn btn-large" href="#">Now</a></div>  
       </div>
        <div class="span2">

        </div>

      </div>

      <hr>

      <footer>
        <p>&copy; Company 2012</p>
      </footer>

    </div> <!-- /container -->

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->

    <script src="/-assets/js/jquery.js"></script>
  <script type="text/javascript">
 
    // I get more list items and either prepend them or append
    // them to the list depending on the target area.
    function getMoreListItems(
      container,
      targetArea,
      onComplete
      ){
      // Check to see if there is any existing AJAX call
      // for the list data items. If there is, we want to
      // return out of this method - no reason to overload
      // the server with extraneous requests (more so than
      // an infinite scroll effect already does!!).
      if (container.data( "xhr" )){
 
        // Let the active AJAX request complete.
        return;
 
      }
      var topDone = (container.data( "topDone" ) || "0");
      var bottomDone = (container.data( "bottomDone" ) || "0");

      if ( 
          ( targetArea=="top" && topDone == "1") ||
          ( targetArea=="bottom" && bottomDone == "1") ) {


      } else {


        // Get the min and max offsets of the current
        // container.
        var minGroup = (container.data( "minGroup" ) || 0);
        var maxGroup = (container.data( "maxGroup" ) || 0);
   
        // The count of list items to load per AJAX request.
        // We are calling it a "chunk" size because each
        // list chunk will be stored in its own sub-container
        // to make DOM manipulation easier.
        var chunkSize = 200;
   
        var baseGroup = maxGroup;
        var count = -chunkSize;

        // Check our target area to see what our next offset
        // for loading should be.
        if (targetArea == "top"){
   
          // We are prepending list items.
          baseGroup = minGroup;
          count = chunkSize;
   
        } 
   
        // Launch AJAX request for next set of results and
        // store the resultant XHR request with the container.
        container.data(
          "xhr",
          $.ajax({
            type: "get",
            url: "/-jtl",
            data: {
              group: baseGroup,
              count: count
            },
            dataType: "json",
            success: function( response ){
              // Apply the response to the container
              // for the given target area.
              applyListItems( container, targetArea, response );
            },
            complete: function(){
              // Remove the stored AJAX request. This
              // will allow subsequent AJAX requests
              // to execute.
              container.removeData( "xhr" );
   
              // Call the onComplete callback.
              onComplete();
            }
          })
        );
      }
    }
  function isEmptyObject(obj) {
    for(var prop in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        return false;
      }
    }
    return true;
  }

 
 
    function applyListItems( container, targetArea, response ){
      var template = $( "#list-item-template" );
      var htmlBuffer = [];

      var groupedItems = response['groups'];
      if (!isEmptyObject(groupedItems)) { 


        $.each(
          groupedItems,
          function( index, group ){            
            htmlBuffer.push("<h2>" + group['label'] + "</h2>");
            $.each(
              group['items'],
              function( index, item ){

                // Modify the template and append the result
                // to the HTML buffer.
                htmlBuffer.push(
                  template.html().replace(
                    new RegExp( "\\$\\{(ts|pid|text|label)\\}", "g" ),
                    function( $0, $1 ){
                      // Return property.
                      return( item[ $1.toLowerCase() ] );
                    }
                  )
                );
       
              }
            );   

          }
        );
   
        // Create a list chunk which will hold our data.
        var chunk = $( "<div class='list-chunk'></div>" );
   
        // Append the list item html buffer to the chunk.
        chunk.append( htmlBuffer.join( "" ) );
   
        // Create the min and max offset of the chunk.
        chunk.data( "minGroup", response['groups'][ 0 ]['label'] );
        chunk.data( "maxGroup", response['groups'][ response['groups'].length - 1 ]['label'] );
   
        // Check to see which target area we are adding the
        // list items to (top vs. bottom).
        if (targetArea == "top"){
   
          // Get the current window scroll before we update
          // the list contente.
          var viewTop = $( window ).scrollTop();
   
          // Prepend list items.
          container.prepend( chunk );
   
          // Now that the chunk has been added to the page,
          // it should have a height that can be calculated.
          var chunkHeight = chunk.height();
   
          // Re-adjust the scroll of the window to make sure
          // the user doesn't suddenly jump to a crazy place.
          $( window ).scrollTop( viewTop + chunkHeight );
   
          // Now that we moved the list up, let's remove
          // the last chunk from the list.
          container.find( "> div.list-chunk:last" ).remove();
   
        } else {
   
          // Append list items.
          container.append( chunk );
   
          // Check to see if we have more chunks than we
          // want (an arbitrary number, but enough to make
          // sure we can comfortable fill the page).
          if (container.children().size() > 8){
   
            // We want to remove the first chunk in the
            // list to free up some browser memory.
   
            // Get the current window scroll before we
            // remove a chunk.
            var viewTop = $( window ).scrollTop();
   
            // Get the chunk that we are going to remove.
            var oldChunk = container.children( ":first" );
   
            // Get the height of the chunk we are about
            // to remove.
            var oldChunkHeight = oldChunk.height();
   
            // Remove the hunk.
            oldChunk.remove();
   
            // Now, we need to ajust the scroll offset
            // of the window so the user is not jumped
            // around to a crazy place.
            $( window ).scrollTop( viewTop - oldChunkHeight );
   
          }
   
        }
      } else {


        if (targetArea == "top"){
          container.data( "topDone", "1" );
        } else {
          container.data( "bottomDone", "1" );
        }
      }

      if (! container.data("firstLoad") ) {

       $('html, body').animate({
         scrollTop: container.children( ":last" ).offset().top
       }, 500);

       container.data("firstLoad", "1")
     }


      // Now that we have updated the chunks in the
      // container, let's update the min / max offsets of
      // the container (which will be used on subsequent
      // AJAX requests).
      container.data(
        "minGroup",
        container.children( ":first" ).data( "minGroup" )
      );
 
      container.data(
        "maxGroup",
        container.children( ":last" ).data( "maxGroup" )
      );
    }
 
 
    // I check to see if more list items are needed based on
    // the scroll offset of the window and the position of
    // the container. I return a complex result that not only
    // determines IF more list items are needed, but on what
    // end of the list.
    //
    // NOTE: These calculate are based ONLY on the offset of
    // the list container in the context of the view frame.
    // This does not take anything else into account (more
    // business logic might be required to see if loading
    // truly needs to take place).
    function isMoreListItemsNeeded( container ){
      // Create a default return. This return value contains
      // requirements for both the top and bottom of the
      // content list.
      var result = {
        top: false,
        bottom: false
      };
 
      // Get the view frame for the window - this is the
      // top and bottom coordinates of the visible slice of
      // the document.
      var viewTop = $( window ).scrollTop();
      var viewBottom = (viewTop + $( window ).height());
 
      // Get the offset of the top of the list container.
      var containerTop = container.offset().top;
 
      // Get the offset of the bottom of the list container.
      var containerBottom = Math.floor(
        containerTop + container.height()
      );
 
      // I am the scroll buffers for the top and the bottom;
      // this is the amount of pre-top and pre-bottom space
      // we want to take into account before we start
      // loading the next items.
      //
      // NOTE: The top buffer is a bit bigger only to make
      // the transition feel a bit *safer*.
      var topScrollBuffer = 80;
      var bottomScrollBuffer = 200;
 console.log("containerTop: " + containerTop);
 console.log("topScrollBuffer: " + topScrollBuffer);
 console.log("viewTop: " + viewTop);
      // Check to see if the container top is close enough
      // (with buffer) to the top scroll of the view frame
      // to trigger loading more items (at the top).
      if ((containerTop + topScrollBuffer) >= viewTop){
 
        // Flag requirement at top.
        result.top = true;
 
      }
 
      // Check to see if the container bottom is close
      // enought (with buffer) to the scroll of the view
      // frame to trigger loading more items (at the
      // bottom).
      if ((containerBottom - bottomScrollBuffer) <= viewBottom){
 
        // Flag requirement at bottom.
        result.bottom = true;
 
      }
 
      // Return the requirments for the loading.
      return( result );
    }
 
 
    // I check to see if more list items are needed, and, if
    // they are, I load them.
    function checkListItemContents( container ){
      // Check to see if more items need to be loaded at
      // the top or the bottom (based purely on position).
      // Returns: { top: boolean, bottom: boolean }.
      var isMoreLoading = isMoreListItemsNeeded( container );
 
      // Define an onComplete method for the AJAX load that
      // will call this method again to make sure there is
      // always enough data loaded on the page.
      var onComplete = function(){
        checkListItemContents( container );
      };
 
      // Check to see if more list items are needed at the
      // top. If so, we will check to offsets to see if the
      // load needs to take place.
      //
      // NOTE: Position is only *part* of how we determine
      // if additional content is needed at the top.
      if (
        isMoreLoading.top &&
        container.data( "minGroup" ) /* &&
        (container.data( "minGroup" ) > 1) */
        ){
 
        // Load and prepend more list items.
        getMoreListItems(
          container,
          "top",
          onComplete
        );
 
      // Check to see if more list items are needed at the
      // bottom. For this, all we are going to rely on is
      // the offset of the container (since we can load
      // ad-infinitum in the bottom direction).
      } else if (isMoreLoading.bottom){
 
        // Load and append more list items.
        getMoreListItems(
          container,
          "bottom",
          onComplete
        );
 
      }
    }
 

    function positionNeedle( container ){ 

    }


    // -------------------------------------------------- //
    // -------------------------------------------------- //
 
 
    // When the DOM is ready, initialize document.
    jQuery(function( $ ){
 
      // Get a reference to the list container.
      var container = $( "#container" );
 
      // Bind the scroll and resize events to the window.
      // Whenever the user scrolls or resizes the window,
      // we will need to check to see if more list items
      // need to be loaded.
      $( window ).bind(
        "scroll resize",
        function( event ){
          // Hand the control-flow off to the method
          // that worries about the list content.
          checkListItemContents( container );
          positionNeedle( container );
        }
      );
 
      // Now that the page is loaded, trigger the "Get"
      // method to populate the list with data.
      checkListItemContents( container );


    });
 
  </script>

<script id="list-item-template" type="application/template">
 
    <div class="list-item">
      <div class="item">
        <h3>${label}</h3>
        <p>${text}</p>
      </div> 
    </div>
 
  </script>

  </body>
</html>